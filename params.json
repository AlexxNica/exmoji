{"name":"Exmoji","tagline":"Emoji encoding swiss army knife for Elixir/Erlang","body":"Exmoji\r\n======\r\nAn Elixir/Erlang library providing low level operations for dealing with Emoji\r\nglyphs in the Unicode standard. :cool:\r\n\r\nExmoji is like a swiss-army knife for dealing with Emoji encoding issues. If all\r\nyou need to do is translate `:poop:` into :poop:, then there are plenty of other\r\nlibs out there that will probably do what you want.  But once you are dealing\r\nwith Emoji as a fundamental part of your application, and you start to realize\r\nthe nightmare of [doublebyte encoding][doublebyte] or [variants][variant], then\r\nthis library may be your new best friend. :raised_hands:\r\n\r\nExmoji is written by the same author as the Ruby [emoji_data.rb][rb] gem, which\r\nis used in production by [Emojitracker.com][emojitracker] to parse well over\r\n100M+ emoji glyphs daily. This version was written to provide all the same\r\nfunctionality while being even higher performance. :dizzy:\r\n\r\n\r\n**WORK IN PROGRESS - NOT RELEASED JUST YET**\r\n\r\n[![Build Status](https://travis-ci.org/mroth/exmoji.svg?branch=master)](https://travis-ci.org/mroth/exmoji)\r\n\r\nNote: `excoveralls` is currently lying, actual test coverage is :100:.\r\n\r\n[doublebyte]: http://www.quora.com/Why-does-using-emoji-reduce-my-SMS-character-limit-to-70\r\n[variant]: http://www.unicode.org/L2/L2011/11438-emoji-var.pdf\r\n[rb]: https://github.com/mroth/emoji_data.rb\r\n[emojitracker]: http://www.emojitracker.com\r\n\r\nInstallation\r\n------------\r\n\r\nAdd it to your deps list in your `mix.exs`. Once this package has been released\r\n_(e.g. not yet)_, you will be able to do:\r\n\r\n```elixir\r\ndefp deps do\r\n  [{:exmoji, \"~> 0.0.1\"}]\r\nend\r\n```\r\n\r\nIn the meantime, or to get the development version, you can pull directly from\r\nGitHub:\r\n\r\n```elixir\r\ndefp deps do\r\n  [{:exmoji, github: \"mroth/exmoji\"}]\r\nend\r\n```\r\n\r\n\r\nModules\r\n-------\r\nFull API documentation is available via standard module docs or here:\r\nTODO\r\n\r\n#### Exmoji\r\nThe main library, with detailed search and conversion functions.\r\n\r\nSome examples:\r\n\r\n```iex\r\niex> Exmoji.from_unified(\"1F680\")\r\n%Exmoji.EmojiChar{name: \"ROCKET\", short_name: \"rocket\", short_names: [\"rocket\"],\r\n text: nil, unified: \"1F680\", variations: []}\r\n\r\niex> Exmoji.find_by_short_name(\"MOON\") |> Enum.count\r\n13\r\n\r\niex> for t <- Exmoji.find_by_name(\"tree\"), do: t.name\r\n[\"EVERGREEN TREE\", \"DECIDUOUS TREE\", \"PALM TREE\", \"CHRISTMAS TREE\",\r\n\"TANABATA TREE\"]\r\n\r\niex> Exmoji.all_doublebyte |> Enum.count\r\n21\r\n```\r\n\r\n#### Exmoji.EmojiChar\r\nA struct representation of a single Emoji character and all of its\r\nassociated metadata.\r\n\r\nThis module also contains some convenience methods for acting upon these\r\nstructs. For example, `EmojiChar.render/1` will produce a bitstring\r\nrepresentation of an Emoji character suitable for transmission.  It understands\r\nwhich Emoji have variant encodings and will do the right thing to make sure they\r\nare likely to display correctly on the other end.\r\n\r\n#### Exmoji.Scanner\r\nProvides very fast searches against binary strings for the presence of UTF-8\r\nencoded Emoji glyphs.  Whereas the Ruby and NodeJS versions of this library\r\naccomplish this via regular expressions, the Elixir version relies on binary\r\npattern matching, making it faster.\r\n\r\nAn example:\r\n\r\n```iex\r\niex> Exmoji.Scanner.scan(\"flying on my ðŸš€ to visit the ðŸ‘¾ people.\")\r\n[%Exmoji.EmojiChar{name: \"ROCKET\", short_name: \"rocket\",\r\n  short_names: [\"rocket\"], text: nil, unified: \"1F680\", variations: []},\r\n %Exmoji.EmojiChar{name: \"ALIEN MONSTER\", short_name: \"space_invader\",\r\n  short_names: [\"space_invader\"], text: nil, unified: \"1F47E\", variations: []}]\r\n```\r\n\r\n\r\nTerminology Note\r\n----------------\r\nThis library uses the term \"char\" extensively to refer to a single emoji glyph\r\nin string encoding.  In Elixir/Erlang `char` means something specific, which\r\nmay be confusing because of the charlist/bitstring division (this library uses\r\nbitstrings).  I may rename all those API functions for this version of the lib\r\nbecause of that, but for now I'm keeping it consistent with the official Unicode\r\nnames for things...\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}